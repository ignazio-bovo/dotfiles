:PROPERTIES:
:ID:       bed0ca38-34ad-4e52-9175-5f5253f1ae67
:END:
#+title: constant product market maker
* Old
** Constant product MM
Suppose I want to build an AMM for the wETH/DAI pair. Set up a pool containing
both ETH and DAI. Two sided marketplace:
- liquidity providers: provide both wETH and DAI tokens
- liquidity takers (aka traders): swap the desired amount of token with the appropriate 
amount of the other token. (eg swap ETH with DAI).
We want that before and after every swap the following rule must be respected:
(amount of wETH = X) x (amount of DAI = Y) = k
If I want to buy dX>0 in exchange for dY>0 then it must be
(X - dX) (y + dY) = k
If (1 - a) is the percentage of fee that is paid to liquidity providers then it must be
(X - dX) (Y + a dY) = k
Hence I am required to deposit:
dY = Y.dX / a.(X - dX)
If I want instead sell a given dY I must withdraw:
dX  = Y.a.dX / (X + a.dX)
from the pool.
This is how Uniswap works. Putting into code:
** Hard treatise
A constant product market maker is trading coins of type BTC for coins of type ETH (and vice
versa). This market Mkt has :
- reserves BTC.res > 0 and ETH.res > 0
- constant product BTC.res * ETH.res = Mkt.const
- percentage fee 1 - Mkt.fee
BTC transition in nthe market trading delta.ETH > 0 coins of type ETH for delta.BTC > 0 coins of
type BTC must satisfy

(BTC.res - delta.BTC) x (ETH.res - Mkt.fee x delta.ETH) = Mkt.const  <-->
I(delta.BTC, delta.ETH) = (BTC.res - delta.BTC) x (ETH.res - Mkt.fee x delta.ETH) - Mkt.const = 0

The above is called invariant I of the automated market maker

This implies that after each transaction the quantities are readjusted as:
1. BTC.res -= delta.BTC
2. ETH.res += delta.ETH
3. Mkt.const = BTC.res * ETH.res

We will always require that BTC.res, ETH.res > 0 such thaht any trade that results in
a nonpositive reserve is never fulfilled.
If Mkt.fee = 0 then any trade must change the reserves in such a way that the product
BTC.res x ETH.res = Mkt.const
** Marginal price
from the rules above we have:
- dY/dX = Y.a/ (X + a.X) (selling X for Y)
- dX/dY = a.(X - dX)/Y (buyng X for Y)
Hence pricing depends on the size of the trade dX. Define the marginal price M = Y/X
then lim dX -> 0 dY/dX = a.M
M is the magnitude of the slope of the tangent line.
Since the market can be taught as a pool with infinite reserve setting 
dX = X.dX/X  -- (my order/outstanding supply).my_order-->  d%.my_order = dX 
d% the percentage of the outstanding token X that I am changing in the market with my
order, M is also the market price.
Pricing depends als on the size of X and Y (i.e. k) and as k increases the effective
price of the AMM is less sensitive to dX
** Liquidity incentives
At pool creation Alice deposits 10 wETH and 12 DAI of liquidity which implies:
M = 1.2  and k = 120
Alice waits for a month, during which trades drive $700 worth of volume through the
AMM. At the end of the month, Alice withdraws her wETH and DAI. By that time, the ratio
of wETH/DAI on the market has gone up 4x. This means the marginal price is now
M' = 4.8 and k = 120 (by def of AMM), assuming a = .997.

- What does Alice earn from liquidity provider fees?
V.(1-a) = 700 * .003 = 2.1 $

- How much value does Alice get when she takes out wETH and DAI from the pool?
a. X.Y = 120 Alice must get back an amount belonging to the AMM curve
b. Y/X = 4.8 (Marginal price)
graphs of a,b intersect at points x,y = 24, 5. Hence Alice will get 24 DAI and 5 wETH.
Hence total profit for Alice will be:

24 DAI + 5 ETH + 2.1 $ = 50.1 DAI

- What if Alice simply held onto her tokens?

12 DAI + 10 ETH = 60 DAI

Thus Alice would have been better if she had hold onto her tokens, the difference
50.1 - 60 = -9.9 DAI is called divergence loss.
** Divergence Loss formula
Notation:
- X, Y original pool composition
- k pool constant
- M = Y/X original marginal price 
- X',Y' pool composition after 1 month
- M' = Y'/ X' market price after 1 month
- r = M'/M (price change)
We have that, 
X = (k/M)**.5 and Y = (kM)**.5, X' = (k/M')**.5 and Y' = (kM')**.5

Liquidity Provider's return = (X'.M' + Y' + V.(1-a))
Hodler's return = X.M' + Y
Divergence loss = LP's return - Hodler's return
P(r) = (Div loss) / (H return) = (2.(r)**.5)/(r+1) + V.(1-a)/c - 1
r -> P(r) is a concave function and optimality is reached when the final price
is equal to that at a liquidity provisioning
** Capital efficiency & Metrics
*** TVL (Total Value Locked) 
Shows the total value of the assets deposited into an AMM
(liquidity providing, staking,...). 
Higher TVL => More liquidity => Less slippage => Better usersâ€™ experience.
*** Trading Volume
Total value of trades occurred on an AMM within a specific period of time, usually 24 hours. 
Higher Trading Volume => More fees => Incentivize users to provide liquidity.
*** Capital Utilization Ratio
Calculated by the formula Trading Volume/TVL, showing the capital efficiency of an AMM.
To be more specific, with the same amount of capital (TVL), the AMM with higher Trading 
Volume will be able to create more fees for Liquidity Providers (efficiency). The lower the ratio the better.
*** Market Cap/TVL
Shows the correlation between Market Cap and TVL, therefore indicating which protocol is broadly trusted 
by the community (high TVL) but is still undervalued (low Market Cap).
The higher the ratio the better.

The Uniswap AMM (constant product) is not very capital efficient a better solution 
is given by Curve.fi using a different AMM rule
** AMM Liquidity Centers
AMM Liquidity Centers implement their own Liquidity Pools. They can easily create
 Liquidity Pools, list assets without relying on a 3rd-party. Eg Uniswap, Sushiswap
** AMM Aggregators
AMM Aggregators gather liquidity from AMM Liquidity Centers. They can integrate
 with Liquidity Pools from multiple AMMs (on the same blockchain) and offer
 the best price options after comparing them between different Liquidity Pools.
 However, their liquidity originates from AMM Liquidity Centers.
Eg. 1inch
** Optimal arbitrage
Crucially, the AMM does not update this price as other markets move around it.
The market price only moves as the reserve ratio of the tokens in the pool changes,
which happens when someone trades against it. To explore an example, what happens 
if the price ETH/BTC to .031 falls on Binance? This implies that Uniswap LPs are corrently
buyng ETH at a premium creating an arbitrage opportunity. As result arbitrageurs
buy cheap ETH on Binance and sell it on Uniswap for an immediate profit. They
keep doing that until the price on Uniswap reaches .031 (same as Binance).
What is the optimal amount to be bought in this case?
Let:
- price.bin = price ETH/BTC observed on binance
- delta_bin.ETH = amount of ETH owned initially this abount is sold on Binance to buy delta.BTC bitcoins
- price.uni = price ETH/BTC observed on uniswap
- delta_uni.ETH = amount of ETH bought on Uniswap for delta.BTC bitcoins
- delta_uni.ETH - delta_bin.ETH = risk free profit

We suppose that the price on Binance reflects the infinite liquidity
outstanding in the market. Then price.bin = delta_bin.ETH / delta.BTC, reflects
the true price (also called marginal price). We want to

MAXIMIZE:        price.bin x delta.BTC - delta_uni.ETH
SUBJECTED TO:    delta.BTC, delta_uni.ETH > 0
                 (BTC.res - delta.BTC) x (ETH.res + Mkt.fee x delta_uni.ETH) = Mkt.const

The marginal price of BTC is defined as the price of an infinitesimally small
trade d(delta.BTC). Which can be found by differentiating 
I(delta.BTC, price_bin x delta.BTC) by
delta.BTC and then taking delta.BTC -> 0. 

price_uni = Mkt.fee x ETH.res / BTC.res = Mkt.fee x price_bin

Then:
- We can always make a non zero risk-free profit if price_uni < Mkt.fee x price_bin
- No arbitrage hence implies price_uni >= Mkt.fee x price_bin

An alagous reasoning swapping ETH with BTC gives that no arbitrage implies 

 Mkt.fee x price_bin <= price_uni <= price_bin / Mkt.fee

This suggests that in practice the larger the trade fees are the larger the 
gap between the true market price and the uniswap market price may be. If 
eps = 1 - Mkt.fee  is small then the above can be written as 

 \| price_uni/price_bin - 1 \| <= eps = 1 - Mkt.fee
** Risk models
There are additional factors which could potentially cause an agent to fail to close
an arbitrage opportunity, including noisy information, front running and delay
in trades (quite common in distributed platforms).
In this case we can add an additional term in penalizing large trades :
- COR(delta.BTC, delta_uni.ETH), called cost of risk, nondecreasing in its second argument
The optimal arbitrage problems now reads as:

MAXIMIZE:        price.bin x delta.BTC - COR(delta.BTC, delta_uni.ETH)
SUBJECTED TO:    delta.BTC, delta_uni.ETH >= 0
                 (BTC.res - delta.BTC) x (ETH.res + Mkt.fee x delta_uni.ETH) = Mkt.const
** Other conditions
** Increasing product constant
For every trade the product constant Mkt.const(t) is non decreasing and strictly increasing
if Mkt.fee < 1. If trade t+1 sells delta.ETH for delta.BTC we have:

Mkt.const(t) = (BTC.res - delta.BTC) x (ETH.res - Mkt.fee x delta.ETH) 
             <= (BTC.res - delta.BTC) x (ETH.res - delta.ETH) 
             = Mkt.const(t+1)

With equality holding if Mkt.fee = 1.

** Splitting trades is more expensive (aka Path dependence)
Buying delta_2.BTC = delta_0.BTC + delta_1.BTC is less expensive than buying
delta_0.BTC and then delta_1.BTC separately

** Non depletion property
It is impossible to fully deplete both ETH.res and BTC.res at any given time: it 
follows from AM >= GM inequality that:

k <= ETH.res x BTC.res <= (.5 x (ETH.res + BTC.res))**2

** Increasing liquidity with increasing reserves
Intuitively the larger the amount of reserves, the less any trade will cost:
differentiating I(delta.BTC, delta.ETH) twice wrt delta.BTC and taking delta.BTC -> 0:

d**2 (delta.ETH) / d(delta.BTC)**2 -> 2 x price_uni / (Mkt.fee x BTC.res)

Note RHS is strictly decreasing as ETH.res increases assuming that price_uni stays
constant

** Cost of manipulation
If an attacker whishes to shift price_bin to be (1 + eps) x price_bin he would requires
an amount of at least

C(eps) >= K ETH.res min(eps**2, sqrt(eps))

for each period (here could be the time taken for a block to be mined)
** Price impact
The difference between the current market price and the expected fill price is 
called price impact, it is a function of:
- size of your trade relative to the size of the liquidity pool
- market invariant being used


* AMM formula
Consider two assets X and Y, consider a decentralized liquidity pool containing x amount of X and y amount of Y.
Then x,y at any point in time are bounded by the formula:

 x * y = K    (constant product market maker formula)

K whose unit is X * Y is a constant established at pool creation.
Suppose a trader wanting to sell \Delta y and buy \Delta x. Suppose that x,y (thought as values denominated in USD) are bound by formulas

a. y = f(x) :=  K / x
b. x = g(y) := f^{-1}(y)

Using first order Taylor expansion

f(x - \Delta x) - f(x) = f'(x) * \Delta x + o(\Delta x)  =>  \Delta y \approx f'(x) \Delta x

f'(x) = - K / x^{2}

quantity f'(x) = dy/dx (x) called marginal price (M.P. for short), namely ratio of a infinitesimal variation in y due to the buying of an infinitesimal variation in x.
Equivalently M.P. can be also thought as the ratio of a variation \Delta y due to the buying of \Delta x in a pool with infinite liquidity. Considering that the market can
be assimilated to such pool we can think M.P. to be equivalent of the market exchange rate Y/X. Denote such rate by P.
Hence we have the following system of equations to which x,y must obey at any point in time:

x * y = K   and   y / x \approx M.P. = P   (AMM eqns)

by integrating the above approximation from 0 to x (amount of asset X in the pool)

Suppose the trade (sell \Delta y and buy \Delta x) happens at time t. Then after the trade (namely at time u = t + \delta) the quantities of the pool will be updated as

x_u = x_t + \Delta x_t 
y_u = K / x_u   (by constant product MM formula)

Giving the new exchange price MP_u = y_u / x_u. 
  
* Market fees
Suppose the Taylor approximation holds (implying that the trade size is negligible wrt the pool liquidity).
In order to provide incentives for LP the pool charges trader a fee \epsilon > 0 at each trade.
So that a trader willing to sell \Delta x of X: 

\Delta y = f(x - \Delta x * (1 - \epsilon)) - f(x) = f'(x) * \Delta x * (1 - \epsilon)    (using above equations)

Suppose the trade happens at time t. Then after the trade (namely at time u = t + \delta) the quantities of the pool will be updated as

x_u = x_t + \Delta x_t * (1 - \epsilon)
y_u = K / x_u   (by constant product MM formula)

Giving the new exchange price MP_u = y_u / x_u. 

* TVL
For a liquidity pool the amount x_t + y_t (denominated in USD) represent the *total value locked* in
the pool at time t, abbreviated as *TLV*.

* Impermanent Loss
Suppose again that Taylor approx holds and we can write: y_t = P_t * x_t for any time t, with P_t exchange price of Y/X at t.
Consider now two points in time t and u > t and imagine two alternative scenarios for a liquidity provider possessing y_t, x_t at time t and
wanting to make a profit at time u. He can choose one of the following two mutually exclusive strategies

a. hodl amount V_t = x_t * P_t + y_t (denominated in units of Y) from time t to time u obtaining V_u[a] = x_t * P_u + y_t
b. deposit amount V_t = x_t * P_t + y_t (denominated in units of Y) into the pool at tie t and take it back at time u obtaining V_u[b] = x_u * P_u + y_u 

The impermanent loss (denominated in unit of Y) is defined as the difference in profit between strategy (b) and strategy (a):

IL(t,u) := V_u[b] - V_u[a] = (x_u * P_u + y_u) - (x_t * P_u + y_t)

Using (AMM eqns) yields:

IL (t,u) =  ((K * P_u)^{1/2} + P_u * (K/P_u)^{1/2} - ( (K * P_t)^{1/2} + P_u * (K/P_t)^{1/2 })

Setting R = P_u / P_t and simplifying gives

IL(t,u) / V_t = R^{1/2} - (R + 1) / 2

* Price Impact
Suppose now a trader is willing to buy some amount of Y by selling \Delta x to the pool, and the trade size is no longer
negligible wrt pool liquidity available. Suppose the market exchange price is P. He gets \Delta y after the trade, define
price impact as:

PI = \Delta y - P * \Delta x * (1 - \epsilon)

Namely the inaccuracy made by using the first order Taylor expansion.

* Slippage
Transactions in Ethereum are generated by a user, submitted to be processed by a miner, and finally added on-chain.
Price Slippage is defined as the percentage variation due to trade latency due to current blockchain
conditions, namely:

| trade price at settlement - Price quoted | / (Price quoted) 

Since slippage is not dependent on the DeX used but on external chain conditions, most DeXes allow
their traders to set specific amount of slippage that they can tolerate (usually 2% or 3%) i.e.
the percentage influence 

One common practice that can influence slippage is front running by other traders:

** Front Running
Consider the following sequential actions by a trader and a front runner
willing to exchange X for Y in a DeX:

1. Trader sees the quoted price P(t)
2. Trader place the order creating a TX with the smart contract address as recipient
3. Order is added to the transaction queue in the nodes wishing to build a block with that transaction
4. Front runner sees the quoted price P(t) and he also wants to exchange X for Y in the same DeX.
5. In order to avoid price P variations due to incoming trades (as those made in 1-3) front runner sets high Gas fee
6. Thanks to higher gas fees miners will surely process front runner's TX earlier than trader's TX

The result is that front runner claims more favourable price P(t) than trader who
gets P(t + dt) even though he would be originally be entitlet to price P(t) by having sent his
order earlier.
