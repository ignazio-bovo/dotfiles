* Extrinsics list
- create channel
- update channel
- delete channel
- create video
- update video
- delete video
- update channel chensorship status
- update video chensorship status
- create channel category
- update channel category
- delete channel category
- create video category
- update video category
- delete video category
* Create Channel
:PROPERTIES:
:Name: =create_channel=
:END:
** Arguments
*** =origin=
:PROPERTIES:
:type: =RawOrigin=
:END:
Signature of the =sender= account.
**** Domain
- =sender= must be the account used for the =actor= context
- =sender= account must have enough balance to deposit bag and objects deletion prize
*** =actor=
:PROPERTIES:
:type: =ContentActor<T::CuratorGroupId, T::CuratorId, T::MemberId>,=
:END:
Context used during channel creation
**** Domain
Must be either a =Member= or a =Curator=
*** =assets=
:PROPERTIES:
:type: =Option<StorageAssets>=
:END:
Optional assets for the channel to be uploaded
**** Domain
- each objects =size= must be smaller enough to be held in one of the bucket
- =expected_data_size_fee= must reflect the value in the storage module
*** =meta=
:PROPERTIES:
:type: =Option<Vec<u8>>=
:END:
Optional metadata content for the assets uploaded
**** Domain
- It shouldn't be =None= if =assets= are not =None= (but it is not a mayor issue)
*** =reward_account=
:PROPERTIES:
:type: =Option<AccountId>=
:END:
Reward account to be used to send reward from the content module. Responsibility for setting this
is left to the creator
*** =collaborators=
:PROPERTIES:
:type: BTreeSet<MemberId>
:END:
Collaborators to be used at channel creation
**** Domain
- member ids specfied must be valid
** Required scenario
- Storage buckets exhisting with sufficient capacity to hold all assets to be uploaded
** Effects
- produces an oustanding channel
- deposit =ChannelCreated= event
- =sender= account is slashed with the amount deposited
- bag for the channel is created
- channel counter is increased
- specified assets are uploaded to storage
* Create Video
:PROPERTIES:
:Name: =create_video=
:END:
** Arguments
*** =origin=
:PROPERTIES:
:type: =RawOrigin=
:END:
Signature of the =sender= account.
**** Domain
- =sender= must be the account used for the =actor= context
- =sender= account must have enough balance to deposit bag and objects deletion prize
*** =actor=
:PROPERTIES:
:type: =ContentActor<T::CuratorGroupId, T::CuratorId, T::MemberId>,=
:END:
Context used during channel creation
**** Domain
- if =Member= or =Curator= he must be the owner of the channel in which the video lives
- if =Collaborator= he must be a registered collaborator in the channel in which the video lives
- if =Lead= then the channel must be owned by a =Curator=
*** =channel_id=
channel to which the video is being uploaded to
**** Domain
- must be a valid id
*** =assets=
:PROPERTIES:
:type: =Option<StorageAssets>=
:END:
Optional assets for the channel to be uploaded
**** Domain
- each objects =size= must be smaller enough to be held in one of the bucket
- =expected_data_size_fee= must reflect the value in the storage module
*** =meta=
:PROPERTIES:
:type: =Option<Vec<u8>>=
:END:
Optional metadata content for the assets uploaded
**** Domain
- It shouldn't be =None= if =assets= are not =None= (but it is not a mayor issue)
** Required scenario
- Storage buckets exhisting with sufficient capacity to hold all assets to be uploaded
** Effects
- produces an oustanding video
- deposit =VideoCreated= event
- =sender= account is slashed with the amount deposited
- video counter is increased
- specified assets are uploaded to storage
- channel video counter is increased by 1
* Update Channel
:PROPERTIES:
:Name: =update_channel=
:END:
** Arguments
*** =origin=
:PROPERTIES:
:type: =RawOrigin=
:END:
Signature of the =sender= account.
**** Domain
- =sender= must be the account used for the =actor= context
- =sender= account must have enough balance to deposit bag and objects deletion prize:
  first upload then assets remove are performed , but that should not lead to a problem since
  one can call the extr twice first to get some balance by removing then a second time to upload.
*** =actor=
:PROPERTIES:
:type: =ContentActor<T::CuratorGroupId, T::CuratorId, T::MemberId>,=
:END:
Context used during channel creation
**** Domain
- if =Member= or =Curator= he must be the owner of the channel in which the video lives
- if =Collaborator= he must be a registered collaborator in the channel in which the video lives
- if =Lead= then the channel must be owned by a =Curator=
*** =assets=
:PROPERTIES:
:type: =Option<StorageAssets>=
:END:
Optional assets for the channel to be uploaded
**** Domain
- each objects =size= must be smaller enough to be held in one of the bucket
- =expected_data_size_fee= must reflect the value in the storage module
- only valid collaborators are allowed to upload assets
- only valid Lead is allowed to upload assets to a curator-owned channel
- only valid (Member or Curator) owner is allowed to upload assets
*** =meta=
:PROPERTIES:
:type: =Option<Vec<u8>>=
:END:
Optional metadata content for the assets uploaded
**** Domain
- It shouldn't be =None= if =assets= are not =None= (but it is not a mayor issue)
*** =reward_account=
:PROPERTIES:
:type: =Option<AccountId>=
:END:
Reward account to be used to send reward from the content module. Responsibility for setting this
is left to the creator
**** Domain
- only channel owner is authorized to edit this parameter
*** =collaborators=
:PROPERTIES:
:type: BTreeSet<MemberId>
:END:
Collaborators to be used at channel creation
**** Domain
- member ids specfied must be valid
- only channel owner is authorized to set this parameter
*** =assets_to_remove=
:PROPERTIES:
:type: BTreeSet<DataObjectId<T>>
:END:
**** Domain
- objects id must be valid in the storage pallet
- only valid collaborators are allowed to upload assets
- only valid Lead is allowed to upload assets to a curator-owned channel
- only valid (Member or Curator) owner is allowed to upload assets  
** Required scenario
- Storage buckets exhisting with sufficient capacity to hold all assets to be uploaded
- Outstanding channel
** Effects
- mutates an oustanding channel
- deposit =ChannelUpdated= event
- =sender= account is slashed with the amount deposited
- =sender= account is credited with the deletion prize 
- specified assets are uploaded to storage
- specified assets (corresponding to the ids) are removed from the storage
* Update Video
:PROPERTIES:
:Name: =update_video=
:END:
** Arguments
*** =origin=
:PROPERTIES:
:type: =RawOrigin=
:END:
Signature of the =sender= account.
**** Domain
- =sender= must be the account used for the =actor= context
- =sender= account must have enough balance to deposit bag and objects deletion prize:
  first upload then assets remove are performed , but that should not lead to a problem since
  one can call the extr twice first to get some balance by removing then a second time to upload.
*** =actor=
:PROPERTIES:
:type: =ContentActor<T::CuratorGroupId, T::CuratorId, T::MemberId>,=
:END:
Context used during channel creation
**** Domain
- if =Member= or =Curator= he must be the owner of the channel in which the video lives
- if =Collaborator= he must be a registered collaborator in the channel in which the video lives
- if =Lead= then the channel must be owned by a =Curator=
*** =assets_to_upload=
:PROPERTIES:
:type: =Option<StorageAssets>=
:END:
Optional assets for the channel to be uploaded
**** Domain
- each objects =size= must be smaller enough to be held in one of the bucket
- =expected_data_size_fee= must reflect the value in the storage module
*** =new_meta=
:PROPERTIES:
:type: =Option<Vec<u8>>=
:END:
Optional metadata content for the assets uploaded
**** Domain
- It shouldn't be =None= if =assets= are not =None= (but it is not a mayor issue)
*** =assets_to_remove=
:PROPERTIES:
:type: BTreeSet<DataObjectId<T>>
:END:
**** Domain
- objects id must be valid in the storage pallet
** Required scenario
- Storage buckets exhisting with sufficient capacity to hold all assets to be uploaded
- Outstanding channel
- outstanding video
** Effects
- mutates an oustanding video
- deposit =VideoUpdated= event
- =sender= account is slashed with the amount deposited due to asset uploading
- =sender= account is credited with the deletion prize due to asest removal
- specified assets are uploaded to storage
- specified assets (corresponding to the ids) are removed from the storage
  
* Delete Channel
:PROPERTIES:
:Name: =create_channel=
:END:
** Arguments
*** =origin=
:PROPERTIES:
:type: =RawOrigin=
:END:
Signature of the =sender= account.
**** Domain
- =sender= must be the account used for the =actor= context
*** =actor=
:PROPERTIES:
:type: =ContentActor<T::CuratorGroupId, T::CuratorId, T::MemberId>,=
:END:
Context used during channel creation
**** Domain
- =Member= or =Curator= must be channel owner
- any other context is not allowed
*** =channel_id=
:PROPERTIES:
:type: =T::ChannelId=
:END:
Id of the channel to be deleted
**** Domain
- must refer to an existing channel
*** =num_objects_to_delete=
:PROPERTIES:
:type: =u64=
:END:
specify the number of assets that the channel owns, this will allow security for weight calculation
**** Domain
- =channel_bag.number_of_objects= must be equal to =objects_to_delete=
** Required scenario
- There must be an outstanding channel existing
** Effects
- bag for the channel is deleted from storage chain state
- all assets for the channel are removed from the storage chain state
- channel is removed from content chain state
- =sender= is rewarded with the deletion prize specified by the bag and the assets removed
- event =DeletedChannel= is deposited
* Delete Video
:PROPERTIES:
:Name: =delete_channel=
:END:
** Arguments
*** =origin=
:PROPERTIES:
:type: =RawOrigin=
:END:
Signature of the =sender= account.
**** Domain
- =sender= must be the account used for the =actor= context
*** =actor=
:PROPERTIES:
:type: =ContentActor<T::CuratorGroupId, T::CuratorId, T::MemberId>,=
:END:
Context used during channel creation
**** Domain
- =Member= or =Curator= must be channel owner
- =Lead= is authorized to remove videos from a =Curator= owned channel
- =Collaborator= must be a registered collaborator for the channel
*** =video_id=
:PROPERTIES:
:type: =T::ChannelId=
:END:
Id of the video to be deleted
**** Domain
- must exist in the content chain state
*** =assets_to_remove=
:PROPERTIES:
:type: =BTreeSet<DataObjectId<T>>=
:END:
assets to be deleted together with the video
**** Domain
- objects id must be existing in storage chain state
** Required scenario
- Outsanding channel
- Outsanding video
** Effects
- all assets for the video are removed from the storage chain state
- video is removed from content chain state
- =sender= is rewarded with the deletion prize specified by the bag and the assets removed
- event =DeletedVideo= is deposited
- channel =num_videos= field is decreased by 1
  
* Permissions
|                     | *Lead*                     | *Curator*                  | *Member*                  | *Collaborator*              |
|---------------------+--------------------------+--------------------------+-------------------------+---------------------------|
| *assets mgmt*         | channel.owner is curator | curator is channel.owner | member is channel.owner | collab in channel.collabs |
| *censorship mgmt*     | true                     | channel.owner is member  | false                   | false                     |
| *category mgmt*       | true                     | true                     | false                   | false                     |
| *collab. set mgmt*    | channel.owner is curator | curator is channel.owner | member is channel.owner | false                     |
| *reward account mgmt* | channel.owner is curator | curator is channel.owner | member is channel.owner | false                     |
| *create channel*      | false                    | true                     | true                    | false                     |
| *delete channel*      | channel.owner is curator | curator is channel.owner | member is channel.owner | false                     |

* Create dynamic bag with object constraints
:PROPERTIES:
:Name: =create_dynamic_bag_with_object_constraints=
:END:
** Arguments
*** =dynamic_bag_id=
:PROPERTIES:
:type: =DynimacBagId<T>=
:END:
Dynamic bag id for the (dynamic) bag you want to create. A dynamic bag can be channel or member
**** Domain
1. =!Bags.contains_key(dynamic_bag_id.into())= must be =true=
*** =deletion_prize=
:PROPERTIES:
:type: =Option<DynamicBagDeletionPrize<T>>=
:END:
optional bag deletion prize and account to whitdraw such prize from
**** Domain
- if =deletion_prize.is_some()=:
  1. =total_balance(deletion_prize.account_id)= <= =deletion_prize.prize + total_objects_upload_fee=
  2. =deletion_prize.accountid = params.deletion_prize_source_account_id=
- else
    1. =total_balance(deletion_prize.account_id)= <= =deletion_prize.prize=
*** =bag_id=
:PROPERTIES:
:type: =BagIdType=
:END:
Bag to upload assets to
**** Domain
  1. =dynamic_bag_id.into() = bag_id=
*** =object_creation_list=
:PROPERTIES:
:type: =Vec<DataObjectCreationParameters>=
:END:
data objects parameters to be uploaded
**** Domain
  1. \forall i : =object_creation_list[i].size > 0=
  2. \forall i : =!object_creation_list[i].ipfs.empty()= && =object_creation_list[i].ipfs= \notin =BlackList=
  3. \sum_i =object_creation_list[i].size < max{ b.avail_size : b.avail_size && b.accepting_bags }=
  4. =object_creation_list.len() < max{ b.avail_num : b.avail_num && b.accepting_bags }=
  5. upload Block
  6. \forall =obj= \in =object_creation_list= =obj.size= < =MaxObjectDataSize=
*** =deletion_prize_source_account_id=
:PROPERTIES:
:type: =AccountId=
:END:
Account to whitdraw objects deletion prize from
**** Domain
  1. =objects_deletion_prize = =T::DataObjectDeletionPrize * object_creation_list.len()=
  2. =Mb_fee = DataObjectPerMegaByteFee=
  3. =upload_fee= = \sum_i =object_creation_list[i].size * Mb_fee=
  4. =total_objects_upload_fee= = =upload_fee + objects_deletion_prize=
  Then it must be:
  - if =deletion_prize.is_some()=:
    1. =total_balance(deletion_prize_source_account_id)= <= =total_objects_upload_fee + deletion_prize.prize=
    2. =deletion_prize.accountid = params.deletion_prize_source_account_id=
  - else:
    1. =total_balance(deletion_prize_source_account_id)= <= =total_objects_upload_fee + deletion_prize.prize=
*** =expected_data_size_fee=
:PROPERTIES:
:type: =Balance=
:END:
expected data size fee value
**** Domain
=expected_data_fee = DataObjectPerMegaByteFee=
** PreConditions
Scenario =S=
1. \exists bucket =b= in =StorageBucketById= such that
  a. let =b.avail_size = b.voucher.size_limit - b.voucher.size_used=, then for =S= require  =b.avail_size > 0=
  b. let =b.avail_num = b.voucher.objects_limit - b.voucher.objects_used=, then for =S= require =b.avail_num > 0=
2. No bag with the specified =bag_id=
** PostConditions
*** Ok
1. =balance_pre - balance_post = bag_deletion_prize=
2. =Bags::contains_key(bag_id)= is true
3. Event is deposited
4. let =bag = =Bags::get(bag_id)=, then \forall =b= \in =bags.stored_by=:
   - \sum_i =object_creation_list[i].size < b.avail_size=
   - =object_creation_list.len() < b.avail_num=
   - =b.accepting_bag= is true
*** Err(err)
1. =balance_pre = balance_post=
2. if =err= \ne ="DynamicBagExists"= =Bags::contains_key(bag_id)= is false

* Upload data objects
:PROPERTIES:
:Name: =upload_data_objects=
:END:
** Arguments
*** =bag_id=
:PROPERTIES:
:type: =BagIdType=
:END:
Bag to upload assets to
**** Domain
  1. =Bags::contains_key(bag_id)= must be =true=
*** =object_creation_list=
:PROPERTIES:
:type: =Vec<DataObjectCreationParameters>=
:END:
data objects parameters to be uploaded
**** Domain
  1. \forall i : =object_creation_list[i].size > 0=
  2. \forall i : =!object_creation_list[i].ipfs.empty()= && =object_creation_list[i].ipfs= \notin =BlackList=
  3. \sum_i =object_creation_list[i].size < max{ b.avail_size : b.avail_size && b.accepting_bags }=
  4. =object_creation_list.len() < max{ b.avail_num : b.avail_num && b.accepting_bags }=
*** =deletion_prize_source_account_id=
:PROPERTIES:
:type: =AccountId=
:END:
Account to whitdraw objects deletion prize from
**** Domain
  1. =objects_deletion_prize = =T::DataObjectDeletionPrize * object_creation_list.len()=
  2. =Mb_fee = DataObjectPerMegaByteFee=
  3. =upload_fee= = \sum_i =object_creation_list[i].size * Mb_fee=
  4. =total_objects_upload_fee= = =upload_fee + objects_deletion_prize=
  Then:
  - =total_balance(deletion_prize_source_account_id)= <= =total_objects_upload_fee=
*** =expected_data_size_fee=
:PROPERTIES:
:type: =Balance=
:END:
expected data size fee value
**** Domain
- if some:
  =expected_data_fee = DataObjectPerMegaByteFee=
** Required Scenario =S=
1. \exists bucket =b= in =StorageBucketById= such that
  a. let =b.avail_size = b.voucher.size_limit - b.voucher.size_used=, then for =S= require  =b.avail_size > 0=
  b. let =b.avail_num = b.voucher.objects_limit - b.voucher.objects_used=, then for =S= require =b.avail_num > 0=

* Delete dynamic bag
:PROPERTIES:
:Name: =delete_dynamic_bag=
:END:
** Arguments
*** =dynamic_bag_id=
:PROPERTIES:
:type: =DynamicBagId<T>=
:END:
Bag to delete from storage
**** Domain
  1. =Bags::contains_key(dynamic_bag_id.into())= must be true
      
*** =deletion_prize_account_id=
:PROPERTIES:
:type: =AccountId=
:END:
 Account to deposit deletion prize
* Delete data objects
:PROPERTIES:
:Name:     =delete_data_objects=
:END:
** Arguments
*** =bag_id=
id of the bag to be edited
**** Domain
1. =Bags::contains_key(bag_id)= must be true
*** =data_objects_id=
:PROPERTIES:
:type: =BTreeSet<DataObjectId>=
:END:
data object ids set to be removed
**** Domain
1. =data_objects_id.empty()= must be false
2. i \in =data_objects_id= \sum_i =DataObjectsById::get(bag_id, i).deletion_prize= <= =StorageTreasury::usable_balance()=
3. \forall i \in =data_objects_id= =DataObjectsById::contains_key(bag_id, i)= must be true
*** =deletion_prize_account_id=
:PROPERTIES:
:type: =AccountId=
:END:
 Account to deposit deletion prize   

* Censorship
* Create channel category
** Arguments
*** =sender=
:PROPERTIES:
:type: =AccountId=
:END:
**** Domain
1. must be auth as =actor=
***  =actor=
:PROPERTIES:
:type:  =ContentActor<CuratorGroupId, CuratorId, MemberId>=
:END:
**** Domain
1. must be either =Lead= or =Curator=
*** =params=
:PROPERTIES:
:type: =ChannelCategoryCreationParameters=
:END:
** PreConditions
1. Valid =(sender, curator_group, curator)= triple
** PostConditions
** PostConditions
*** Ok
1. Event deposited
2. Category is adde to the =CategoryById= map
3. =NextCategoryId= counter increased by =1=
*** Err(err)
1. No category added to the =CategoryById= map
2. =NextCategoryId= not increased
* Create video category
** Arguments
*** =sender=
:PROPERTIES:
:type: =AccountId=
:END:
**** Domain
1. must be auth as =actor=
***  =actor=
:PROPERTIES:
:type:  =ContentActor<CuratorGroupId, CuratorId, MemberId>=
:END:
**** Domain
1. must be either =Lead= or =Curator=
*** =params=
:PROPERTIES:
:type: =ChannelCategoryCreationParameters=
:END:
** PreConditions
1. Valid =(sender, curator_group, curator)= triple
** PostConditions
*** Ok
1. Event deposited
2. Category is adde to the =CategoryById= map
3. =NextCategoryId= counter increased by =1=
*** Err(err)
1. No category added to the =CategoryById= map
2. =NextCategoryId= not increased
* Update channel category
** Arguments
*** =sender=
:PROPERTIES:
:type: =AccountId=
:END:
**** Domain
1. must be auth as =actor=
***  =actor=
:PROPERTIES:
:type:  =ContentActor<CuratorGroupId, CuratorId, MemberId>=
:END:
**** Domain
1. must be either =Lead= or =Curator=
*** =params=
:PROPERTIES:
:type: =ChannelCategoryCreationParameters=
:END:
*** =category_id=
:PROPERTIES:
:type: =CategoryId=
:END:
**** Domain
1. =ChannelCategoryById::<T>::contains_key(category_id)= is =true=
** PreConditions
1. Valid =(sender, curator_group, curator)= triple
2. =Category= at =ChannelCategoryById::get(category_id)= exists
** PostConditions
*** Ok
1. Event deposited
*** Err(err)
1. =Category= is not modified if =err= \ne =CategoryDoesNotExist=

* Update video category
** Arguments
*** =sender=
:PROPERTIES:
:type: =AccountId=
:END:
**** Domain
1. must be auth as =actor=
***  =actor=
:PROPERTIES:
:type:  =ContentActor<CuratorGroupId, CuratorId, MemberId>=
:END:
**** Domain
1. must be either =Lead= or =Curator=
*** =params=
:PROPERTIES:
:type: =ChannelCategoryCreationParameters=
:END:
*** =category_id=
:PROPERTIES:
:type: =CategoryId=
:END:
**** Domain
1. =VideoCategoryById::<T>::contains_key(category_id)= is =true=
** PreConditions
1. Valid =(sender, curator_group, curator)= triple
2. =Category= at =VideoCategoryById::get(category_id)= exists
** PostConditions
*** Ok
1. Event deposited
*** Err(err)
* Delete channel category
** Arguments
*** =sender=
:PROPERTIES:
:type: =AccountId=
:END:
**** Domain
1. must be auth as =actor=
***  =actor=
:PROPERTIES:
:type:  =ContentActor<CuratorGroupId, CuratorId, MemberId>=
:END:
**** Domain
1. must be either =Lead= or =Curator=
*** =params=
:PROPERTIES:
:type: =ChannelCategoryCreationParameters=
:END:
*** =category_id=
:PROPERTIES:
:type: =CategoryId=
:END:
**** Domain
1. =CatetegoryById::<T>::contains_key(category_id)= is =true=
** PreConditions
1. Valid =(sender, curator_group, curator)= triple
2. =Category= at =ChannelCategoryById::get(category_id)= exists
** PostConditions
*** Ok
1. Event deposited
2. =Category= removed from =ChannelCategoryById= map
*** Err(err)
1. =Category= NOT removed from =ChannpelCategoryById= map
* Delete video category
** Arguments
*** =sender=
:PROPERTIES:
:type: =AccountId=
:END:
**** Domain
1. must be auth as =actor=
***  =actor=
:PROPERTIES:
:type:  =ContentActor<CuratorGroupId, CuratorId, MemberId>=
:END:
**** Domain
1. must be either =Lead= or =Curator=
*** =params=
:PROPERTIES:
:type: =VideoCategoryCreationParameters=
:END:
*** =category_id=
:PROPERTIES:
:type: =CategoryId=
:END:
**** Domain
1. =CatetegoryById::<T>::contains_key(category_id)= is =true=
** PreConditions
1. Valid =(sender, curator_group, curator)= triple
2. =Category= at =VideoCategoryById::get(category_id)= exists
** PostConditions
*** Ok
1. Event deposited
2. =Category= removed from =VideoCategoryById= map
*** Err(err)
1. =Category= NOT removed from =VideoCategoryById= map


